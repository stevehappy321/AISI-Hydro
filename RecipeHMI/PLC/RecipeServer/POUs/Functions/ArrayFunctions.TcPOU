<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="ArrayFunctions" Id="{8379035e-f7a7-4ce9-b778-733c860bab40}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK ArrayFunctions
VAR
	j : DINT;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Folder Name="Remover Helpers" Id="{53e6427c-1a22-4e81-81a4-96258dbfe570}" />
    <Folder Name="Sorting Helpers" Id="{e0db0d41-f5d9-4c4b-83ce-75f5c6c58779}" />
    <Method Name="removeCardboard" Id="{184d302e-cc7b-4149-9d71-e6711fc53c9c}" FolderPath="Remover Helpers\">
      <Declaration><![CDATA[{attribute 'TcRpcEnable'}
METHOD removeCardboard : BOOL
VAR_INPUT
	i : INT; //index to be removed
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[MEMMOVE(ADR(StrapWrapRecipe.Cardboard[i]), ADR(StrapWrapRecipe.Cardboard[i+1]), (GVL.maxMaterials-i)*SIZEOF(PositionMaterials));
StrapWrapRecipe.Cardboard[GVL.maxMaterials].position := 0;
StrapWrapRecipe.Cardboard[GVL.maxMaterials].top := '';
StrapWrapRecipe.Cardboard[GVL.maxMaterials].sides := '';
StrapWrapRecipe.Cardboard[GVL.maxMaterials].bottom := '';
StrapWrapRecipe.Cardboard[GVL.maxMaterials].upperCorner := '';
StrapWrapRecipe.Cardboard[GVL.maxMaterials].lowerCorner := '';]]></ST>
      </Implementation>
    </Method>
    <Method Name="removeChipboard" Id="{cfb27708-d6f2-4f4f-8c56-9104577269eb}" FolderPath="Remover Helpers\">
      <Declaration><![CDATA[{attribute 'TcRpcEnable'}
METHOD removeChipboard : BOOL
VAR_INPUT
	i : INT; //index to be removed
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[MEMMOVE(ADR(StrapWrapRecipe.Chipboard[i]), ADR(StrapWrapRecipe.Chipboard[i+1]), (GVL.maxMaterials-i)*SIZEOF(PositionMaterials));
StrapWrapRecipe.Chipboard[GVL.maxMaterials].position := 0;
StrapWrapRecipe.Chipboard[GVL.maxMaterials].top := '';
StrapWrapRecipe.Chipboard[GVL.maxMaterials].sides := '';
StrapWrapRecipe.Cardboard[GVL.maxMaterials].bottom := '';
StrapWrapRecipe.Chipboard[GVL.maxMaterials].upperCorner := '';
StrapWrapRecipe.Chipboard[GVL.maxMaterials].lowerCorner := '';]]></ST>
      </Implementation>
    </Method>
    <Method Name="removeCornerGuard" Id="{200d85ab-c82d-44b1-9ef8-ae667b8149f6}" FolderPath="Remover Helpers\">
      <Declaration><![CDATA[{attribute 'TcRpcEnable'}
METHOD removeCornerGuard : BOOL
VAR_INPUT
	i : INT; //index to be removed
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[MEMMOVE(ADR(StrapWrapRecipe.CornerGuard[i]), ADR(StrapWrapRecipe.CornerGuard[i+1]), (GVL.maxMaterials-i)*SIZEOF(PositionMaterials));
StrapWrapRecipe.CornerGuard[GVL.maxMaterials].position := 0;
StrapWrapRecipe.CornerGuard[GVL.maxMaterials].top := '';
StrapWrapRecipe.CornerGuard[GVL.maxMaterials].sides := '';
StrapWrapRecipe.CornerGuard[GVL.maxMaterials].bottom := '';
StrapWrapRecipe.CornerGuard[GVL.maxMaterials].upperCorner := '';
StrapWrapRecipe.CornerGuard[GVL.maxMaterials].lowerCorner := '';]]></ST>
      </Implementation>
    </Method>
    <Method Name="removePaper" Id="{32580bb3-936b-4ab0-964c-72e04f77b0d2}" FolderPath="Remover Helpers\">
      <Declaration><![CDATA[{attribute 'TcRpcEnable'}
METHOD removePaper: BOOL
VAR_INPUT
	face : STRING;
	i : DINT; //index to be removed
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF face = 'Top' THEN
	MEMMOVE(ADR(StrapWrapRecipe.TopPaper[i]), ADR(StrapWrapRecipe.TopPaper[i+1]), (GVL.maxMaterials-i)*SIZEOF(PaperInterval));
	StrapWrapRecipe.TopPaper[GVL.maxMaterials].start := 0;
	StrapWrapRecipe.TopPaper[GVL.maxMaterials].end := 0;
ELSIF face = 'Sides' THEN
	MEMMOVE(ADR(StrapWrapRecipe.TopPaper[i]), ADR(StrapWrapRecipe.TopPaper[i+1]), (GVL.maxMaterials-i)*SIZEOF(PaperInterval));
	StrapWrapRecipe.TopPaper[GVL.maxMaterials].start := 0;
	StrapWrapRecipe.TopPaper[GVL.maxMaterials].end := 0;
ELSIF face = 'Bottom' THEN
	MEMMOVE(ADR(StrapWrapRecipe.TopPaper[i]), ADR(StrapWrapRecipe.TopPaper[i+1]), (GVL.maxMaterials-i)*SIZEOF(PaperInterval));
	StrapWrapRecipe.TopPaper[GVL.maxMaterials].start := 0;
	StrapWrapRecipe.TopPaper[GVL.maxMaterials].end := 0;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="removeWoodBunk" Id="{efb14e3a-6daf-4f18-99c2-b627d1203a1c}" FolderPath="Remover Helpers\">
      <Declaration><![CDATA[{attribute 'TcRpcEnable'}
METHOD removeWoodBunk : BOOL
VAR_INPUT
	i : INT; //index to be removed
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[MEMMOVE(ADR(StrapWrapRecipe.WoodBunk[i]), ADR(StrapWrapRecipe.WoodBunk[i+1]), (GVL.maxMaterials-i)*SIZEOF(PositionMaterials));
StrapWrapRecipe.WoodBunk[GVL.maxMaterials].position := 0;
StrapWrapRecipe.WoodBunk[GVL.maxMaterials].top := '';
StrapWrapRecipe.WoodBunk[GVL.maxMaterials].sides := '';
StrapWrapRecipe.WoodBunk[GVL.maxMaterials].bottom := '';
StrapWrapRecipe.WoodBunk[GVL.maxMaterials].upperCorner := '';
StrapWrapRecipe.WoodBunk[GVL.maxMaterials].lowerCorner := '';]]></ST>
      </Implementation>
    </Method>
    <Method Name="sortEntries" Id="{1df04f1b-4cbc-4b80-8e0b-fe8cc9d780e2}">
      <Declaration><![CDATA[{attribute 'TcRpcEnable'}
METHOD sortEntries : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[sortPositionMaterials(StrapWrapRecipe.Cardboard);
sortPositionMaterials(StrapWrapRecipe.CornerGuard);
sortPositionMaterials(StrapWrapRecipe.Chipboard);
sortPositionMaterials(StrapWrapRecipe.WoodBunk);

sortPaperIntervals(StrapWrapRecipe.TopPaper);
sortPaperIntervals(StrapWrapRecipe.SidesPaper);
sortPaperIntervals(StrapWrapRecipe.BottomPaper);]]></ST>
      </Implementation>
    </Method>
    <Method Name="sortPaperIntervals" Id="{57f03265-1675-4066-bf88-7e49818ceb13}" FolderPath="Sorting Helpers\">
      <Declaration><![CDATA[METHOD sortPaperIntervals : BOOL
VAR_IN_OUT
	arr : ARRAY[*] OF PaperInterval;
END_VAR
VAR_INST
	i : DINT;
	j : DINT;
	temp : PaperInterval;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR i:=LOWER_BOUND(arr, 1) TO UPPER_BOUND(arr, 1) BY 1 DO
	FOR j:=LOWER_BOUND(arr, 1) TO UPPER_BOUND(arr, 1)-i-1 BY 1 DO
		IF 
			(arr[j].start = 0 AND arr[j].end = 0) //unused entry
			OR 
			arr[j].start > arr[j+1].start AND //out of order and both entries are valid
			NOT(arr[j+1].start = 0 AND arr[j+1].end = 0)
		THEN //unused entry or out of order
			MEMCPY(ADR(temp), ADR(arr[j]), SIZEOF(PaperInterval));
			MEMCPY(ADR(arr[j]), ADR(arr[j+1]), SIZEOF(PaperInterval));
			MEMCPY(ADR(arr[j+1]), ADR(temp), SIZEOF(PaperInterval));
		END_IF
	END_FOR
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="sortPositionMaterials" Id="{f22e62e0-e849-4c4b-8871-11869f65530f}" FolderPath="Sorting Helpers\">
      <Declaration><![CDATA[METHOD sortPositionMaterials : BOOL
VAR_IN_OUT
	arr : ARRAY[*] OF PositionMaterials;
END_VAR
VAR_INST
	i : DINT;
	j : DINT;
	temp : PositionMaterials;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR i:=LOWER_BOUND(arr, 1) TO UPPER_BOUND(arr, 1)-1 BY 1 DO
	FOR j:=LOWER_BOUND(arr, 1) TO UPPER_BOUND(arr, 1)-i-1 BY 1 DO
		IF //unused entry
			(arr[j].top = '' AND arr[j].sides = '' AND arr[j].bottom = '' AND arr[j].upperCorner = '' AND arr[j].lowerCorner = '')
		THEN //unused entry
			arr[j].position := 0; //set position to 0
			MEMCPY(ADR(temp), ADR(arr[j]), SIZEOF(PositionMaterials));
			MEMCPY(ADR(arr[j]), ADR(arr[j+1]), SIZEOF(PositionMaterials));
			MEMCPY(ADR(arr[j+1]), ADR(temp), SIZEOF(PositionMaterials));
		ELSIF //out of order and both entries are valid
			arr[j].position > arr[j+1].position AND 
			NOT(arr[j+1].top = '' AND arr[j+1].sides = '' AND arr[j+1].bottom = '' AND arr[j+1].upperCorner = '' AND arr[j+1].lowerCorner = '')
		THEN
			MEMCPY(ADR(temp), ADR(arr[j]), SIZEOF(PositionMaterials));
			MEMCPY(ADR(arr[j]), ADR(arr[j+1]), SIZEOF(PositionMaterials));
			MEMCPY(ADR(arr[j+1]), ADR(temp), SIZEOF(PositionMaterials));
		END_IF
	END_FOR
END_FOR]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="ArrayFunctions">
      <LineId Id="104" Count="0" />
    </LineIds>
    <LineIds Name="ArrayFunctions.removeCardboard">
      <LineId Id="22" Count="1" />
      <LineId Id="15" Count="0" />
      <LineId Id="24" Count="3" />
    </LineIds>
    <LineIds Name="ArrayFunctions.removeChipboard">
      <LineId Id="22" Count="5" />
      <LineId Id="15" Count="0" />
    </LineIds>
    <LineIds Name="ArrayFunctions.removeCornerGuard">
      <LineId Id="22" Count="5" />
      <LineId Id="15" Count="0" />
    </LineIds>
    <LineIds Name="ArrayFunctions.removePaper">
      <LineId Id="87" Count="1" />
      <LineId Id="108" Count="1" />
      <LineId Id="89" Count="0" />
      <LineId Id="110" Count="1" />
      <LineId Id="90" Count="1" />
      <LineId Id="112" Count="1" />
      <LineId Id="92" Count="1" />
    </LineIds>
    <LineIds Name="ArrayFunctions.removeWoodBunk">
      <LineId Id="22" Count="5" />
      <LineId Id="15" Count="0" />
    </LineIds>
    <LineIds Name="ArrayFunctions.sortEntries">
      <LineId Id="5" Count="3" />
      <LineId Id="10" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="11" Count="1" />
    </LineIds>
    <LineIds Name="ArrayFunctions.sortPaperIntervals">
      <LineId Id="7" Count="2" />
      <LineId Id="36" Count="0" />
      <LineId Id="35" Count="0" />
      <LineId Id="37" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="10" Count="4" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="ArrayFunctions.sortPositionMaterials">
      <LineId Id="6" Count="1" />
      <LineId Id="47" Count="0" />
      <LineId Id="55" Count="0" />
      <LineId Id="61" Count="0" />
      <LineId Id="54" Count="0" />
      <LineId Id="50" Count="1" />
      <LineId Id="48" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="66" Count="2" />
      <LineId Id="71" Count="1" />
      <LineId Id="69" Count="0" />
      <LineId Id="62" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>