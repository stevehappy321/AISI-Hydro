<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="SectionEx" Id="{553a7cf7-8736-4fc0-93d1-2ae972262b14}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK ABSTRACT SectionEx
VAR_INPUT
	enable : BOOL;
	sectionID : SectionEnum;
END_VAR
VAR_IN_OUT
	bundlesQueue : ARRAY[*] OF Bundle;
	conveyorsArr : ARRAY[*] OF POINTER TO ConveyorSC;
	//in addition to the conveyos array, each section must receive references to the origial conveyors the array elements point to
END_VAR
VAR_OUTPUT
	activeBundle : Bundle; //assigned if there is a bundle to target
	bypass : BOOL; //assigned once the bundle head passes the section (status >= ACTIVE)
END_VAR
VAR_OUTPUT //PackML states + controls
	run : BOOL;
	stop : BOOL;
	hold : BOOL;
	reset : BOOL;
	
	ready : BOOL;
	busy : BOOL;
	done : BOOL;
	error : BOOL;
	
	pmlModeString : STRING;
	pmlStateString : STRING;
	
	pmlState : E_PMLState;
	pmlMode : E_PMLCustomUnitMode;
	
	iBundle : INT(0..Consts.maxQueue);
	iPair : INT(0..Consts.maxPairs);
END_VAR
VAR //PackML types
	pmlCommand : E_PMLCommand;
	pmlModeRequest : E_PMLCustomUnitMode := ePMLCustomUnitMode_Production;
	
	pmlStateMachine : PML_StateMachine;
	pmlModeManager : PML_UnitModeManager;
	pmlSemiAutoConfig : PML_UnitModeConfig;
END_VAR
VAR
	execute AT %M* : BOOL; //change to %I* depending on needs
	trigger : R_TRIG;
	
	currentBundle : REFERENCE TO Bundle;
	loadedMaterials : ARRAY[Surface.TOP..Surface.BOTTOM_RIGHT] OF STRING;

	requestedConveyorMode : ConveyorMode;
	conveyorPos : REAL;
	
	nextSection : POINTER TO SectionEx;
	prevSection : POINTER TO SectionEx;
	
	occupied : BOOL; //may be a dedicated sensor or a conveyor sensor
	
	status : SectionTask; //section status
END_VAR
VAR_STAT CONSTANT
	INCLUSIVE : INT := 0;
	EXCLUSIVE : INT := 1;
	COMPLETE : INT := 1030;
	
	suctionReleaseDelay : TIME := T#1000MS;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[currentBundle REF= bundlesQueue[iBundle];
bypass := currentBundle.bypass;

ready := status = 0;
busy := status > 0;
done := done;
error := error;

blocks();
configPmlModes();

trigger(CLK:= execute, Q=> );

(*
PackML
	state machine for packaging applications - see Tc3_PackML_V2 library on InfoSys
	
	final states - wait for an input or condition and command to new state
	intermediate states - complete a task and call pmlStateMachine.M_StateComplete() to advance to next state
	
the following states currently use the same logic (albeit in different methods), implementation may change later
	ps_Stopping() and ps_Aborting()
	ps_Resetting() and ps_Clearing()
	
STOP - controlled stop **with intent to shutdown or vacate for extended time** induced by operator/HMI - otherwise use HOLD
ABORT - emergency stop due to machine errors

HOLD - minor local issues
SUSPEND - external issues

EXECUTE - major control logic
	different modes may require different tasks
	create methods as required for different modes, then call the correct method in ps_Completing()
	can be commanded to STOP, ABORT, HOLD, or SUSPEND at any point
COMPLETING - process complete, move product out of system and finish transition to COMPLETED

the implementation below can be copied to all POUs that use a PackML state machine
the individual ps_< > methods need to be implemented for the specific application
*)

IF ps_AbortCondition() THEN //abort condition
	pmlCommand := ePMLCommand_Abort;
ELSIF ps_StopCondition() THEN //stop condition
	pmlCommand := ePMLCommand_Stop;
END_IF

CASE pmlState OF
	0 (*ePMLState_Undefined*): //default state on startup
		pmlCommand := ePMLCommand_Stop;
		
	ePMLState_Stopping:
		IF ps_Stopping() THEN
			pmlStateMachine.M_StateComplete();
		END_IF
		
	ePMLState_Stopped:
		IF ps_Stopped() THEN
			pmlCommand := ePMLCommand_Reset;
		END_IF
	
    ePMLState_Resetting:
		IF ps_Resetting() THEN
			pmlStateMachine.M_StateComplete();
		END_IF
		
	ePMLState_Idle:
		IF ps_Idle() THEN
			pmlCommand := ePMLCommand_Start;
		END_IF		
	
	ePMLState_Starting:
		IF ps_Starting() THEN
			pmlStateMachine.M_StateComplete();
		END_IF
	
	ePMLState_Execute: //check the conditions in order of their priority, currently HOLD has the highest priority
		IF ps_HoldCondition() THEN
			pmlCommand := ePMLCommand_Hold;
			
		ELSIF ps_SuspendCondition() THEN
			pmlCommand := ePMLCommand_Suspend;			
		
		ELSIF ps_Execute(error => error) THEN //ps_Execute.error => THIS^.error
			pmlStateMachine.M_StateComplete();
			pmlCommand := ePMLCommand_Complete;
		END_IF
		
	ePMLState_Completing:
		IF ps_Completing() THEN
			pmlStateMachine.M_StateComplete();
		END_IF
	
	ePMLState_Complete:
		IF ps_Complete() THEN
			pmlCommand := ePMLCommand_Reset;
		END_IF
	
	ePMLState_Holding:
		IF ps_Holding() THEN
			pmlStateMachine.M_StateComplete();
		END_IF
	
	ePMLState_Held:
		IF NOT hold THEN
			pmlCommand := ePMLCommand_Unhold;
		END_IF
	
	ePMLState_Unholding:
		IF ps_Unholding() THEN
			pmlStateMachine.M_StateComplete(); //release all pause commands and IO
		END_IF
		
	ePMLState_Suspending: //based on next section conditions
		IF ps_Suspending() THEN
			pmlStateMachine.M_StateComplete();
		END_IF
		
	ePMLState_Suspended: //based on next section conditions
		IF ps_Suspended() THEN
			pmlCommand := ePMLCommand_Unsuspend;
		END_IF
	
	ePMLState_Unsuspending: //based on next section conditions
		IF ps_Unsuspending() THEN
			pmlStateMachine.M_StateComplete();
		END_IF
	
	ePMLState_Aborting:
		IF ps_Aborting() THEN
			pmlStateMachine.M_StateComplete();
		END_IF
	
	ePMLState_Aborted:
		IF ps_Aborted() THEN
			pmlCommand := ePMLCommand_Clear;
		END_IF
	
	ePMLState_Clearing:
		IF ps_Clearing() THEN
			pmlStateMachine.M_StateComplete();
		END_IF
	
END_CASE]]></ST>
    </Implementation>
    <Folder Name="Abstract" Id="{931032f8-8fbc-437e-9feb-8dfcf4d8fa11}" />
    <Folder Name="PML Conditions" Id="{8f6247d2-5ca2-410c-b633-82ec4b58b07b}" />
    <Folder Name="PML States" Id="{06e2f1cf-cccc-459b-a09f-1383a082a445}" />
    <Folder Name="Properties" Id="{35099ffa-f285-4e22-8f2e-31de1316393c}" />
    <Method Name="blocks" Id="{ed2226fe-fd00-49fe-b482-5d0d616dd13b}">
      <Declaration><![CDATA[METHOD PROTECTED blocks : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[pmlModeManager(
	bExecute:= NOT pmlModeManager.bExecute, 
	eModeCommand:= pmlModeRequest, 
	eState:= pmlState, 
	eModeStatus=> pmlMode, 
	sModeStatus=> pmlModeString, 
	bDone=> , 
	bError=> , 
	nErrorId=> );

pmlStateMachine(
	eMode:= pmlMode, 
	eCommand:= pmlCommand, 
	stSubUnitInfoRef:= , 
	stOptions:= , 
	eState=> pmlState, 
	sState=> pmlStateString, 
	bError=> , 
	nErrorID=> );]]></ST>
      </Implementation>
    </Method>
    <Method Name="configPmlModes" Id="{d11051fc-bac3-457c-818f-f7c03f9a4087}">
      <Declaration><![CDATA[METHOD PROTECTED configPmlModes : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[pmlSemiAutoConfig(
	eMode:= 4, 
	sName:= 'SemiAuto', 
	bDisableClearing:= FALSE, 
	bDisableStarting:= FALSE, 
	bDisableSuspended:= FALSE, 
	bDisableStopping:= FALSE, 
	bDisableAborting:= FALSE, 
	bDisableHolding:= FALSE, 
	bDisableHeld:= FALSE, 
	bDisableUnholding:= FALSE, 
	bDisableSuspending:= FALSE, 
	bDisableUnsuspending:= FALSE, 
	bDisableResetting:= FALSE, 
	bDisableIdle:= FALSE, 
	bDisableCompleting:= FALSE, 
	bDisableComplete:= FALSE, 
	bEnableUnitModeChangeStopped:= TRUE, 
	bEnableUnitModeChangeIdle:= TRUE, 
	bEnableUnitModeChangeSuspended:= FALSE, 
	bEnableUnitModeChangeExecute:= FALSE, 
	bEnableUnitModeChangeAborted:= TRUE, 
	bEnableUnitModeChangeHeld:= FALSE, 
	bEnableUnitModeChangeComplete:= FALSE, 
	bError=> , 
	nErrorId=> );]]></ST>
      </Implementation>
    </Method>
    <Method Name="connectTo" Id="{91d63988-c603-4003-a46a-ea71ce206f50}">
      <Declaration><![CDATA[METHOD connectTo : BOOL
VAR_INPUT
	connectedSection : POINTER TO SectionEx;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[nextSection := connectedSection;

IF connectedSection <> 0 THEN
	connectedSection^.prevSection := THIS;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="directionCheckAndSet" Id="{e472cb3d-3b10-43cb-be34-a868e55e86de}">
      <Declaration><![CDATA[METHOD PROTECTED directionCheckAndSet : BOOL
VAR_INPUT
	conveyorRef : REAL;
	target : REAL;
END_VAR
//returns true conveyorRef is in range of target]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF WithinTolerance(value:= conveyorRef, target:= target, tolerance:= CONSTS.precisionTolerance) THEN
	directionCheckAndSet := TRUE;
	
ELSIF conveyorRef > target THEN
	pConveyorMode := ConveyorMode.BACKWARD;
	
ELSIF conveyorRef < target THEN
	pConveyorMode := ConveyorMode.FORWARD;
	
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="load" Id="{f29da0bd-18e9-4eca-8ea7-a82a57710347}" FolderPath="Abstract\">
      <Declaration><![CDATA[METHOD PROTECTED ABSTRACT load : BOOL
VAR_INPUT
	pairIndex : INT;
END_VAR
VAR_OUTPUT
	error : BOOL;
END_VAR
(*
loading takes place while the section is NOT active
materials are loaded for the next incoming bundle, not the current bundle - may differ for each section
*)]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="maintenance" Id="{82cfe381-4627-47b2-becb-4530cc701c9e}" FolderPath="Abstract\">
      <Declaration><![CDATA[METHOD PROTECTED ABSTRACT maintenance : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="manual" Id="{ff0cde2d-d380-4afd-90d8-2768840c481a}" FolderPath="Abstract\">
      <Declaration><![CDATA[METHOD PROTECTED ABSTRACT manual : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Property Name="pConveyorMode" Id="{97786c27-ba47-43a5-9b90-47ff6f5d538e}" FolderPath="Properties\">
      <Declaration><![CDATA[PROPERTY PROTECTED pConveyorMode : ConveyorMode]]></Declaration>
      <Get Name="Get" Id="{0ba095f3-28cd-449d-a6ee-3c87c3d0580a}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[pConveyorMode := requestedConveyorMode;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{af1867f9-e8bf-4840-a3e8-76c799395c42}">
        <Declaration><![CDATA[VAR
	i : DINT;
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[requestedConveyorMode := pConveyorMode;

FOR i:=LOWER_BOUND(conveyorsArr, 1) TO UPPER_BOUND(conveyorsArr, 1) BY 1 DO
	
	CASE status OF
		SectionTask.ALIGN, -100:
			//all conveyors requested to same mode
			conveyorsArr[i]^.setRequest(requestedConveyorMode);
			
		SectionTask.ACTIVE, SectionTask.DISCHARGE:
			//once previous bundle catches up, the conveyor that bundle sits on must be linked to this section
			//a conveyor control module will handle linking
			
			IF conveyorsArr[i]^.IsOccupied THEN //follow this section's request
				conveyorsArr[i]^.setRequest(requestedConveyorMode);
				
			ELSE //catch up succeeding bundle (FOLLOW PREVIOUS SECTION)
				IF prevSection <> 0 THEN
					conveyorsArr[i]^.setRequest( prevSection^.pConveyorMode );
				END_IF
			END_IF
	END_CASE	
	
END_FOR]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="process" Id="{d318af18-2aae-4a8a-9d12-4aa1944ee865}" FolderPath="Abstract\">
      <Declaration><![CDATA[METHOD PROTECTED ABSTRACT process : BOOL
VAR_INPUT
	auto : BOOL;
END_VAR
VAR_OUTPUT
	error : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[(*
this method is implemented by each section according to their material packaging steps
*)]]></ST>
      </Implementation>
    </Method>
    <Method Name="ps_AbortCondition" Id="{ea0e69dc-628b-404a-acfd-eb96c20b5c8b}" FolderPath="PML Conditions\">
      <Declaration><![CDATA[METHOD PROTECTED ABSTRACT ps_AbortCondition : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="ps_Aborted" Id="{fd49a85e-d9c2-4872-999c-4e48c3f35296}" FolderPath="PML States\">
      <Declaration><![CDATA[METHOD PROTECTED ABSTRACT ps_Aborted : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="ps_Aborting" Id="{8970a2ca-c21c-49d9-911e-491db2e7f876}" FolderPath="PML States\">
      <Declaration><![CDATA[METHOD PROTECTED ABSTRACT ps_Aborting : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="ps_Clearing" Id="{3fe44078-6a1b-4682-a996-b699c18aee67}" FolderPath="PML States\">
      <Declaration><![CDATA[METHOD PROTECTED ABSTRACT ps_Clearing : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="ps_Complete" Id="{7833c15a-3310-48e7-8e31-e7e76e3a7760}" FolderPath="PML States\">
      <Declaration><![CDATA[METHOD PROTECTED ABSTRACT ps_Complete : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="ps_Completing" Id="{38fedc81-0bce-4ee0-9445-9aadde8a30b1}" FolderPath="PML States\">
      <Declaration><![CDATA[METHOD PROTECTED ABSTRACT ps_Completing : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="ps_Execute" Id="{73635fe5-de92-40d6-ba2e-8b3bfdfdbb4e}" FolderPath="PML States\">
      <Declaration><![CDATA[METHOD PROTECTED FINAL ps_Execute : BOOL
VAR_INPUT
END_VAR
VAR_OUTPUT
	error : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE pmlMode OF
	0: //invalid mode
	ePMLCustomUnitMode_Production:		ps_Execute := runSectionTasks(auto := TRUE);
	ePMLCustomUnitMode_Maintenance:		ps_Execute := maintenance();
	ePMLCustomUnitMode_Manual:			ps_Execute := manual();
	ePMLCustomUnitMode_SemiAuto:		ps_Execute := runSectionTasks(auto := FALSE);
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="ps_Held" Id="{97712eef-0a76-4f44-b2a5-7edb9768c1c5}" FolderPath="PML States\">
      <Declaration><![CDATA[METHOD PROTECTED ABSTRACT ps_Held : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="ps_HoldCondition" Id="{18584675-3920-466d-95ca-bc68955d5f21}" FolderPath="PML Conditions\">
      <Declaration><![CDATA[METHOD PROTECTED ABSTRACT ps_HoldCondition : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="ps_Holding" Id="{ae1a5d1d-c425-41ab-be42-ac322799fb37}" FolderPath="PML States\">
      <Declaration><![CDATA[METHOD PROTECTED ABSTRACT ps_Holding : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="ps_Idle" Id="{ff5dce02-ada7-431d-9ee9-3e17c3a65b4e}" FolderPath="PML States\">
      <Declaration><![CDATA[METHOD PROTECTED FINAL ps_Idle : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[ps_Idle := run := run OR trigger.Q; (*start section input*)]]></ST>
      </Implementation>
    </Method>
    <Method Name="ps_Resetting" Id="{cb59b9e4-db36-4a6b-b9fd-e8381e0607d8}" FolderPath="PML States\">
      <Declaration><![CDATA[METHOD PROTECTED ABSTRACT ps_Resetting : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="ps_Starting" Id="{e89dce85-4a66-44ea-857c-1f5cdfba177a}" FolderPath="PML States\">
      <Declaration><![CDATA[METHOD PROTECTED ABSTRACT ps_Starting : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="ps_StopCondition" Id="{a23289dd-9264-41ec-8cf7-f6c6d2f4f445}" FolderPath="PML Conditions\">
      <Declaration><![CDATA[METHOD PROTECTED ABSTRACT ps_StopCondition : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="ps_Stopped" Id="{8e007499-8af0-4da7-be9e-f073186adcc7}" FolderPath="PML States\">
      <Declaration><![CDATA[METHOD PROTECTED ABSTRACT ps_Stopped : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="ps_Stopping" Id="{1dcebf3c-702f-49e3-8dfe-b35094ec6ccc}" FolderPath="PML States\">
      <Declaration><![CDATA[METHOD PROTECTED ABSTRACT ps_Stopping : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="ps_SuspendCondition" Id="{fc9d4281-9a99-493c-9484-446186deee9d}" FolderPath="PML Conditions\">
      <Declaration><![CDATA[METHOD PROTECTED ABSTRACT ps_SuspendCondition : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="ps_Suspended" Id="{505c98ae-539c-49e2-a739-19c90e70899f}" FolderPath="PML States\">
      <Declaration><![CDATA[METHOD PROTECTED ABSTRACT ps_Suspended : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="ps_Suspending" Id="{cced8904-3605-41d0-8646-a0d5e2e475a7}" FolderPath="PML States\">
      <Declaration><![CDATA[METHOD PROTECTED ABSTRACT ps_Suspending : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="ps_Unholding" Id="{d1211bb0-9bf2-475e-9bc3-fc66e3405f66}" FolderPath="PML States\">
      <Declaration><![CDATA[METHOD PROTECTED ABSTRACT ps_Unholding : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="ps_Unsuspending" Id="{177b454f-a063-4ea7-a664-efbf79a9bb04}" FolderPath="PML States\">
      <Declaration><![CDATA[METHOD PROTECTED ABSTRACT ps_Unsuspending : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="runSectionTasks" Id="{ff600a76-8305-47bd-9f4f-604426e1af1d}">
      <Declaration><![CDATA[METHOD PROTECTED runSectionTasks : BOOL
VAR_INPUT
	auto : BOOL;
END_VAR
VAR_OUTPUT
	error : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE status OF
	SectionTask.IDLE:
		IF BundleIsValid(currentBundle) THEN			
			status := SectionTask.ALIGN;
			done := FALSE;
		END_IF
	
	SectionTask.ALIGN:		
		pConveyorMode := ConveyorMode.FORWARD;
		
		IF occupied THEN
			(*
			from here, there are 2 possible events:
				the expected bundle has arrived - proceed as normal
				a previously completed bundle backed up into this section - store the current position as 0 and go to STATUS -100
			*)
			pConveyorMode := ConveyorMode.STOP;
			
			IF nextSection <> 0 AND_THEN nextSection^.pConveyorMode = ConveyorMode.BACKWARD THEN
				status := -100;
				
			ELSIF NOT auto OR_ELSE trigger.Q THEN
				//zero the conveyors again
				status := SectionTask.ACTIVE;
				
			END_IF
		END_IF
		
	SectionTask.ACTIVE:
		activeBundle := currentBundle;
		
		IF NOT enable THEN
			iPair := 0;
			status := SectionTask.DISCHARGE;
			
		ELSIF currentBundle.bypass (*AND_THEN discharge()*) THEN //bundle failed in previous section, discharge this section's materials
			IF unload() THEN
				iPair := 0;
				status := SectionTask.DISCHARGE;
			END_IF
			
		ELSIF process(auto := auto, error => error) THEN //bundle recipe completed normally
			IF NOT auto OR_ELSE trigger.Q THEN
				iPair := 0;
				status := SectionTask.DISCHARGE;
			END_IF			
		END_IF
		
	SectionTask.DISCHARGE:
		activeBundle := currentBundle;
		pConveyorMode := ConveyorMode.FORWARD;
		
		IF conveyorPos >= currentBundle.length AND NOT occupied THEN //rear of bundle has cleared the area
			status := SectionTask.COMPLETE;
		END_IF
		
	SectionTask.COMPLETE:	
		iBundle := iBundle + 1;
		//bundleOut := GVL.nullBundle;
		MEMSET(ADR(activeBundle), 0, SIZEOF(activeBundle));
		
		status := SectionTask.IDLE;
		
		runSectionTasks := TRUE;
		
	-100: //previously completed bundle reversed into this section		
		pConveyorMode := ConveyorMode.FORWARD;
		
		IF NOT occupied AND conveyorPos = 0 THEN
			status := SectionTask.ALIGN;
		END_IF
		
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="shiftIterator" Id="{2b1c8dba-7a66-41d7-be54-23459718f73e}">
      <Declaration><![CDATA[METHOD shiftIterator : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[//2023-10-24 - array of pointers replaced with iterator for MAIN's queue passed by pointer
iBundle := iBundle - 1;]]></ST>
      </Implementation>
    </Method>
    <Method Name="unload" Id="{264daea0-fc50-4810-8136-0464ba4deabe}" FolderPath="Abstract\">
      <Declaration><![CDATA[METHOD PROTECTED ABSTRACT unload : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(*
unload, unstage, etc
*)]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="SectionEx">
      <LineId Id="4141" Count="0" />
      <LineId Id="4143" Count="140" />
      <LineId Id="3926" Count="0" />
    </LineIds>
    <LineIds Name="SectionEx.blocks">
      <LineId Id="6" Count="17" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="SectionEx.configPmlModes">
      <LineId Id="6" Count="24" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="SectionEx.connectTo">
      <LineId Id="5" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="14" Count="2" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="SectionEx.directionCheckAndSet">
      <LineId Id="7" Count="3" />
      <LineId Id="21" Count="0" />
      <LineId Id="12" Count="1" />
      <LineId Id="22" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="SectionEx.load">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="SectionEx.maintenance">
      <LineId Id="20" Count="0" />
    </LineIds>
    <LineIds Name="SectionEx.manual">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="SectionEx.pConveyorMode.Get">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="SectionEx.pConveyorMode.Set">
      <LineId Id="2" Count="0" />
      <LineId Id="8" Count="4" />
      <LineId Id="33" Count="0" />
      <LineId Id="13" Count="10" />
      <LineId Id="25" Count="4" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="SectionEx.process">
      <LineId Id="28" Count="0" />
      <LineId Id="89" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="SectionEx.ps_AbortCondition">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="SectionEx.ps_Aborted">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="SectionEx.ps_Aborting">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="SectionEx.ps_Clearing">
      <LineId Id="13" Count="0" />
    </LineIds>
    <LineIds Name="SectionEx.ps_Complete">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="SectionEx.ps_Completing">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="SectionEx.ps_Execute">
      <LineId Id="67" Count="3" />
      <LineId Id="78" Count="0" />
      <LineId Id="72" Count="0" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="SectionEx.ps_Held">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="SectionEx.ps_HoldCondition">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="SectionEx.ps_Holding">
      <LineId Id="17" Count="0" />
    </LineIds>
    <LineIds Name="SectionEx.ps_Idle">
      <LineId Id="18" Count="0" />
    </LineIds>
    <LineIds Name="SectionEx.ps_Resetting">
      <LineId Id="6" Count="0" />
    </LineIds>
    <LineIds Name="SectionEx.ps_Starting">
      <LineId Id="15" Count="0" />
    </LineIds>
    <LineIds Name="SectionEx.ps_StopCondition">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="SectionEx.ps_Stopped">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="SectionEx.ps_Stopping">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="SectionEx.ps_SuspendCondition">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="SectionEx.ps_Suspended">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="SectionEx.ps_Suspending">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="SectionEx.ps_Unholding">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="SectionEx.ps_Unsuspending">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="SectionEx.runSectionTasks">
      <LineId Id="480" Count="8" />
      <LineId Id="549" Count="1" />
      <LineId Id="571" Count="0" />
      <LineId Id="575" Count="2" />
      <LineId Id="574" Count="0" />
      <LineId Id="572" Count="0" />
      <LineId Id="578" Count="0" />
      <LineId Id="551" Count="0" />
      <LineId Id="553" Count="0" />
      <LineId Id="566" Count="0" />
      <LineId Id="554" Count="0" />
      <LineId Id="570" Count="0" />
      <LineId Id="565" Count="0" />
      <LineId Id="567" Count="0" />
      <LineId Id="555" Count="0" />
      <LineId Id="552" Count="0" />
      <LineId Id="503" Count="44" />
      <LineId Id="373" Count="0" />
    </LineIds>
    <LineIds Name="SectionEx.shiftIterator">
      <LineId Id="17" Count="0" />
      <LineId Id="19" Count="0" />
    </LineIds>
    <LineIds Name="SectionEx.unload">
      <LineId Id="5" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="9" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>